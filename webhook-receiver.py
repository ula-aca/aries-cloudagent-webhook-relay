#!/usr/bin/env python3

import argparse
import asyncio
import aiohttp
from aiohttp import web
import json
import logging
from uuid import uuid4

app = web.Application()
app.msg_queue = asyncio.Queue()
routes = web.RouteTableDef()

# CLI Argument Setup
parser = argparse.ArgumentParser(
    prog='webhook-receiver',
    description="collects and cache's aca-py webhook calls until requested by controller."
    )
parser.add_argument(
    '-l', '--log',
    action='store',
    choices=['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG'],
    default='INFO',
    help='the log level'
    )

parser.add_argument(
    '--api-key',
    action='store',
    help='if passed, this will be used as the API key (one will be generated by default).'
    )
parser.add_argument(
    '--insecure-mode',
    action='store_true',
    help='if passed, no API key will be generated and the --api-key flag will be ignored.'
)

parser.add_argument(
    '--host',
    '-H', 
    action='store', 
    default='0.0.0.0',
    help='the host the receiver will run on'
    )
parser.add_argument(
    '--port', 
    '-p', 
    action='store', 
    default=8080,
    help='the port the receiver will run on'
    )
args = parser.parse_args()



class Topic:
    CONNECTIONS = 'connections'
    BASICMESSAGES = 'basicmessages'
    ISSUE_CREDENTIAL = 'issue_credential'
    PRESENT_PROOF = 'present_proof'

class Message:
    def __init__(self, topic: Topic, payload: dict):
        self.topic = topic
        self.payload = payload

    def to_json(self) -> str:
        return json.dumps(self.__dict__)


async def on_ws_connection(request):
    ws = web.WebSocketResponse()

    await ws.prepare(request)
    if not args.insecure_mode:
        provided_key = request.headers['Authorization']
        if provided_key != args.api_key:
            logging.warning(f'denied connection attempt with invalid api key {provided_key}')
            await ws.close()
            return

    while not ws.closed:
        msg = await request.app.msg_queue.get()
        await ws.send_str(msg.to_json())
        
    return ws

@routes.post('/topic/connections/')
async def connections_handler(request):
    msg = Message(Topic.CONNECTIONS, await request.json())
    await request.app.msg_queue.put(msg)
    return web.Response(status=200)

@routes.post('/topic/basicmessages/')
async def basicmessages_handler(request):
    msg = Message(Topic.BASICMESSAGES, await request.json())
    await request.app.msg_queue.put(msg)
    return web.Response(status=200)

@routes.post('/topic/issue_credential/')
async def issue_credential_handler(request):
    msg = Message(Topic.ISSUE_CREDENTIAL, await request.json())
    await request.app.msg_queue.put(msg)
    return web.Response(status=200)

@routes.post('/topic/present_proof/')
async def present_proofs_handler(request):
    msg = Message(Topic.PRESENT_PROOF, await request.json())
    await request.app.msg_queue.put(msg)
    return web.Response(status=200)

@routes.get('/new-messages')
async def new_messages_handler(request):
    response = []
    while not request.app.msg_queue.empty():
        msg = await request.app.msg_queue.get()
        response.append(msg.to_json())

    return web.Response(body=json.dumps(response))

if __name__ == '__main__':

    logging.basicConfig(level=args.log, format='%(levelname)s - %(message)s')
    logging.info(f'log level: {args.log}')

    app.add_routes(routes)  # add routes


    if args.insecure_mode is False:
        if args.api_key is None:
            args.api_key = str(uuid4())
            logging.info('both the --api-key and --insecure-mode flags are not provided')
            logging.info(f'generated api key: {args.api_key}')
    else:
        logging.warning('running in insecure mode, don\'t use this in production!')
    
    logging.info(f'ws exposed at: ws://{args.host}:{args.port}/ws')

    app.add_routes([web.get('/ws', on_ws_connection)])  # add webdocket route

    web.run_app(app, host=args.host, port=args.port)